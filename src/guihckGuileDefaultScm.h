#ifndef GUIHCKGUILEDEFAULTSCM_H
#define GUIHCKGUILEDEFAULTSCM_H

static const char GUIHCK_GUILE_DEFAULT_SCM[] =
    "(define (flatmap f xs) (apply append (map f xs)))"

    "(define (create-elements! . elements)"
    "  (for-each (lambda (e) (e)) elements))"

    "(define (create-element type nested-args)"
    "  (define (flatten-args as)"
    "    (define (flatten-arg a)"
    "      (define (flattenable? a) (and (list? a) (eq? (car a) 'arg-list)))"
    "      (if (flattenable? a)"
    "        (flatten-args (cdr a))"
    "        (list a)))"
    "    (flatmap flatten-arg as))"

    "  (define args (flatten-args nested-args))"

    "  (define (set-id)"
    "    (define (id? d) (and (list? d) (eq? (car d) 'id)))"
    "    (for-each (lambda (id) (set-element-property! 'id (cadr id)))"
    "              (filter id? args)))"

    "  (define (eval-children)"
    "    (define child? procedure?)"
    "    (for-each (lambda (child) (child))"
    "              (filter child? args)))"

    "  (define (set-props)"
    "    (define (prop? d) (and (list? d) (eq? (list-ref d 0) 'prop)))"
    "    (define (bind? v) (and (list? v) (eq? (list-ref v 0) 'bind)))"
    "    (define (make-bind value)"
    "      (list 'bind ((list-ref value 1)) (list-ref value 2)))"
    "    (for-each (lambda (p)"
    "                (let ((key (list-ref p 1)) (value (list-ref p 2)))"
    "                  (if (bind? value)"
    "                    (set-element-property! key (make-bind value))"
    "                    (set-element-property! key value))))"
    "              (filter prop? args)))"

    "  (lambda ()"
    "    (push-new-element! type)"
    "    (set-id)"
    "    (eval-children)"
    "    (set-props)"
    "    (if (procedure? (get-element-property 'init))"
    "      ((get-element-property 'init)))"
    "    (pop-element!)))"

    "(define (arg-list args) (cons 'arg-list args))"

    "(define (prop key value) (list 'prop key value))"
    "(define (id value) (list 'id value))"

    "(define (composite constructor . default-args)"
    "  (lambda (. args)"
    "    (apply constructor (append default-args args))))"

    "(define set-prop!"
    "  (case-lambda"
    "    ((property value) (set-prop! (get-element) property value))"
    "    ((element property value)"
    "      (push-element! element)"
    "      (set-element-property! property value)"
    "      (pop-element!))))"

    "(define get-prop"
    "  (case-lambda"
    "    ((property) (get-prop (get-element) property))"
    "    ((element property)"
    "      (push-element! element)"
    "      (let ((value (get-element-property property)))"
    "        (pop-element!)"
    "        value))))"

    "(define this get-element)"

    "(define (find-element id)"
    "  (begin"
    "    (push-element-by-id! id)"
    "    (let ((result-element (get-element)))"
    "      (pop-element!)"
    "      result-element)))"

    "(define parent"
    "  (case-lambda"
    "    (() (parent (get-element)))"
    "    ((element)"
    "      (push-element! element)"
    "      (push-parent-element!)"
    "      (let ((parent-element (get-element)))"
    "        (pop-element!)"
    "        (pop-element!)"
    "        parent-element))))"


    "(define child"
    "  (case-lambda"
    "    ((index) (child (get-element) index))"
    "    ((element index)"
    "      (push-element! element)"
    "      (push-child-element! index)"
    "      (let ((child-element (get-element)))"
    "        (pop-element!)"
    "        (pop-element!)"
    "        child-element))))"

    "(define children"
    "  (case-lambda"
    "    (() (children (get-element)))"
    "    ((element)"
    "      (push-element! element)"
    "      (let ((n (get-element-child-count)))"
    "        (define (iter i lst)"
    "          (if (< i n)"
    "            (begin"
    "              (push-child-element! i)"
    "              (let ((c (get-element)))"
    "                (pop-element!)"
    "                (iter (+ i 1) (cons c lst))))"
    "            lst))"
    "        (let ((result (reverse! (iter 0 '()))))"
    "          (pop-element!)"
    "          result)))))"

    "(define (observe . vals)"
    "  (define (resolve e)"
    "    (cond ((eq? e 'parent) (parent))"
    "          ((eq? e 'this) (this))"
    "          (else (find-element e))))"
    "  (define (pairs lst)"
    "    (if (null? lst)"
    "      '()"
    "      (cons (cons (car lst) (cadr lst)) (pairs (cddr lst)))))"
    "  (define (process pair)"
    "    (cons (resolve (car pair)) (cdr pair)))"
    "  (map process (pairs vals)))"

    "(define bind"
    "  (case-lambda"
    "    ((property callback) (bind (this) property callback))"
    "    ((element property callback)"
    "      (add-element-property-listener! element property callback))))"

    "(define (bound bindings callback)"
    "  (list 'bind (lambda () (apply observe bindings)) callback))"

    "(define unbind remove-element-property-listener!)"

    "(define focus!"
    "  (case-lambda"
    "    (() (keyboard-focus!))"
    "    ((element)"
    "      (push-element! element)"
    "      (keyboard-focus!)"
    "      (pop-element!))))"
    ;
#endif // GUIHCKGUILEDEFAULTSCM_H
